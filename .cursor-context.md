# Contexto do Projeto - API de Assistente de IA

## ğŸ“Œ Estado Atual

**Status**: âœ… Estrutura inicial completa

**Ãšltima atualizaÃ§Ã£o**: 2024

## ğŸ¯ Objetivo do Projeto

API REST que processa descriÃ§Ãµes de bugs/melhorias/requisitos usando Google Gemini e retorna JSON estruturado para preenchimento automÃ¡tico de formulÃ¡rios no frontend.

## ğŸ—ï¸ Arquitetura

### Stack TecnolÃ³gico
- **Runtime**: Node.js com TypeScript (ESM modules)
- **Framework**: Fastify 4.x
- **IA**: Google Gemini (`@google/generative-ai`)
- **DocumentaÃ§Ã£o**: Swagger/OpenAPI com `@fastify/swagger` e `@fastify/swagger-ui`
- **CORS**: `@fastify/cors`
- **Ambiente**: `dotenv`

### Estrutura de Pastas
```
casosApi/
â”œâ”€â”€ server.ts                 # Servidor principal Fastify
â”œâ”€â”€ package.json             # DependÃªncias e scripts
â”œâ”€â”€ tsconfig.json            # ConfiguraÃ§Ã£o TypeScript (strict mode, ESM)
â”œâ”€â”€ .env.example             # Template de variÃ¡veis de ambiente
â”œâ”€â”€ .gitignore               # Arquivos ignorados pelo git
â”œâ”€â”€ README.md                # DocumentaÃ§Ã£o do projeto
â”œâ”€â”€ routes/                  # Rotas da API
â”‚   â”œâ”€â”€ index.ts            # GET / (boas-vindas)
â”‚   â”œâ”€â”€ health.ts           # GET /health (health check)
â”‚   â””â”€â”€ assistant.ts        # POST /api/assistant (processamento)
â”œâ”€â”€ services/               # ServiÃ§os de negÃ³cio
â”‚   â””â”€â”€ ai-service.ts       # IntegraÃ§Ã£o com Google Gemini
â”œâ”€â”€ types/                  # Tipos TypeScript
â”‚   â””â”€â”€ assistant.ts        # Request/Response types
â”œâ”€â”€ prompts/                # Templates de prompts
â”‚   â””â”€â”€ form-assistant.ts   # Prompt para processamento
â””â”€â”€ docs/                   # DocumentaÃ§Ã£o Swagger
    â”œâ”€â”€ routes/             # Schemas das rotas
    â”‚   â”œâ”€â”€ index.ts
    â”‚   â”œâ”€â”€ health.ts
    â”‚   â””â”€â”€ assistant.ts
    â””â”€â”€ schemas/            # Schemas JSON
        â”œâ”€â”€ assistant.ts
        â””â”€â”€ common.ts
```

## ğŸ”‘ DecisÃµes TÃ©cnicas

### 1. TypeScript Strict Mode
- **DecisÃ£o**: Usar TypeScript com `strict: true`
- **Motivo**: Maior seguranÃ§a de tipos, detecta erros em tempo de compilaÃ§Ã£o
- **Impacto**: Evita uso de `any`, forÃ§a tipagem completa

### 2. ESM Modules
- **DecisÃ£o**: Usar ES Modules (`import/export`) com extensÃ£o `.js` nos imports TypeScript
- **Motivo**: PadrÃ£o moderno, melhor tree-shaking, suporte nativo no Node.js
- **Nota**: TypeScript compila para ESM, mas imports devem usar `.js`

### 3. Fastify ao invÃ©s de Express
- **DecisÃ£o**: Usar Fastify como framework
- **Motivo**: Melhor performance, suporte nativo a JSON Schema, plugins modulares
- **BenefÃ­cio**: ValidaÃ§Ã£o automÃ¡tica de requests/responses

### 4. Google Gemini
- **DecisÃ£o**: Usar Google Gemini (modelo `gemini-2.0-flash` por padrÃ£o)
- **ConfiguraÃ§Ã£o**: 
  - Temperature: 0.2 (mais determinÃ­stico)
  - Response MIME Type: `application/json` (forÃ§a resposta JSON)
  - Max Output Tokens: 2048

### 5. Estrutura de Resposta PadrÃ£o
- **DecisÃ£o**: Sempre retornar `{ success: boolean, ... }`
- **Motivo**: ConsistÃªncia na API, fÃ¡cil tratamento de erros no frontend
- **Formato de Sucesso**: `{ success: true, data: {...}, confidence, processedIn }`
- **Formato de Erro**: `{ success: false, error: "mensagem" }`

### 6. ValidaÃ§Ã£o com JSON Schema
- **DecisÃ£o**: Usar JSON Schema para validaÃ§Ã£o de requests/responses
- **Motivo**: ValidaÃ§Ã£o automÃ¡tica pelo Fastify, documentaÃ§Ã£o Swagger automÃ¡tica
- **LocalizaÃ§Ã£o**: Schemas em `docs/schemas/`

### 7. Tratamento de Erros
- **DecisÃ£o**: Error handler global + tratamento especÃ­fico por rota
- **EstratÃ©gia**: 
  - 400: Erros de validaÃ§Ã£o
  - 500: Erros internos
  - Sempre retornar formato padronizado

### 8. Logging
- **DecisÃ£o**: Usar `fastify.log` (Pino) com pretty print em desenvolvimento
- **Motivo**: Logs estruturados, fÃ¡cil integraÃ§Ã£o com ferramentas de monitoramento

## ğŸ“ VariÃ¡veis de Ambiente

```env
GEMINI_API_KEY=your-api-key-here    # ObrigatÃ³ria
GEMINI_MODEL=gemini-2.0-flash       # Opcional (default: gemini-2.0-flash)
PORT=3001                           # Opcional (default: 3001)
```

## ğŸ”„ Fluxo de Processamento

1. **Request** â†’ `POST /api/assistant` com `{ description: string }`
2. **ValidaÃ§Ã£o** â†’ JSON Schema valida o request
3. **AIService** â†’ Processa com Gemini usando prompt template
4. **Parse** â†’ Extrai JSON da resposta da IA
5. **ValidaÃ§Ã£o** â†’ Valida estrutura e categoria
6. **Response** â†’ Retorna JSON estruturado com mÃ©tricas

## ğŸ¨ Categorias Suportadas

- `BUG`: Problemas/erros no sistema
- `MELHORIA`: SugestÃµes de melhorias
- `REQUISITO`: Novos requisitos/funcionalidades

## ğŸ“Š MÃ©tricas Retornadas

- `confidence`: NÃ­vel de confianÃ§a (0-1) - atualmente fixo em 0.95
- `processedIn`: Tempo de processamento em milissegundos

## ğŸš€ Scripts DisponÃ­veis

- `npm run dev`: Desenvolvimento com watch (tsx)
- `npm run build`: Compila TypeScript
- `npm start`: Executa versÃ£o compilada
- `npm run type-check`: Verifica tipos sem compilar

## ğŸ”® Melhorias Futuras (Opcional)

- [ ] MÃ©tricas de performance (latÃªncia, taxa de sucesso)
- [ ] HistÃ³rico de processamentos (em memÃ³ria ou persistido)
- [ ] Endpoint para consultar mÃ©tricas
- [ ] Suporte a mÃºltiplos formatos de entrada (Ã¡udio, etc.)
- [ ] Cache de respostas similares
- [ ] Rate limiting
- [ ] AutenticaÃ§Ã£o/autorizaÃ§Ã£o

## âš ï¸ Pontos de AtenÃ§Ã£o

1. **GEMINI_API_KEY**: Deve ser configurada no `.env` (nÃ£o commitada)
2. **CORS**: Configurado para aceitar todas as origens em desenvolvimento
3. **Error Handling**: AIService pode falhar se API key invÃ¡lida
4. **JSON Parsing**: Pode tentar extrair JSON se resposta tiver texto adicional

## ğŸ“š DocumentaÃ§Ã£o Swagger

DisponÃ­vel em: `http://localhost:3001/docs`

Tags:
- `assistant`: Endpoints do assistente de IA
- `health`: Health check

## ğŸ” Como Consultar Este Arquivo

Este arquivo serve como referÃªncia rÃ¡pida para:
- Entender decisÃµes arquiteturais
- Revisar estrutura do projeto
- Consultar configuraÃ§Ãµes importantes
- Planejar melhorias futuras

**Economiza tokens** ao evitar perguntas sobre decisÃµes jÃ¡ documentadas.
